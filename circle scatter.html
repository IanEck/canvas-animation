<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Circles with Adjusted Sizes and Padding</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-size: 16px; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        #controls { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.7); padding: 10px; z-index: 10; }
        #layout-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            pointer-events: none;
        }
        #window-circle {
            width: 8rem;
            height: 8rem;
            margin-top: 2rem;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.2);
        }
        #overlay {
            width: 80%;
            max-width: 600px;
            height: 60%;
            margin-top: 2rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            pointer-events: auto;
            padding: 1rem;
        }
        #overlay iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <label>Blend Mode: 
            <select id="blendMode">
                <option value="source-over">Normal</option>
                <option value="screen">Screen</option>
                <option value="multiply">Multiply</option>
                <option value="overlay">Overlay</option>
                <option value="difference">Difference</option>
            </select>
        </label>
        <br>
        <label>Opacity: <input type="range" id="opacity" min="0" max="1" step="0.1" value="0.7"></label>
    </div>
    <div id="layout-container">
        <div id="window-circle"></div>
        <div id="overlay">
            <!-- Replace the src with your actual embedded form URL -->
            <iframe src="about:blank" frameborder="0"></iframe>
        </div>
    </div>
    <script>
        (function() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const blendModeSelect = document.getElementById('blendMode');
            const opacityInput = document.getElementById('opacity');
            const windowCircle = document.getElementById('window-circle');

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();

            function remToPx(rem) {
                return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
            }

            const circleDiameter = 8; // Changed to 8 rems
            const circleRadius = remToPx(circleDiameter) / 2;

            const frictionFactor = 0.995;
            const minSpeed = 0.5;
            const maxSpeed = 10;
            const returnDuration = 1000;
            const explosiveSpeed = 30;

            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return [r, g, b];
            }

            function updateWindowCirclePosition() {
                const rect = windowCircle.getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2,
                    radius: rect.width / 2
                };
            }

            let windowCirclePos = updateWindowCirclePosition();

            const circles = [
                { x: canvas.width * 0.2, y: canvas.height * 0.2, radius: circleRadius, color: hexToRgb('#ef476f'), vx: 6, vy: 5 },
                { x: canvas.width * 0.4, y: canvas.height * 0.4, radius: circleRadius, color: hexToRgb('#ffd166'), vx: -5, vy: 6 },
                { x: canvas.width * 0.6, y: canvas.height * 0.6, radius: circleRadius, color: hexToRgb('#06d6a0'), vx: -4, vy: -5.5 },
                { x: canvas.width * 0.8, y: canvas.height * 0.8, radius: circleRadius, color: hexToRgb('#118ab2'), vx: 3, vy: -4 },
                { x: canvas.width * 0.5, y: canvas.height * 0.5, radius: circleRadius, color: hexToRgb('#073b4c'), vx: -2, vy: 3 },
            ];

            let isReturning = false;
            let returnStartTime;

            const gifUrls = [
                '/images/cloud cutouts.png',
                '/images/cloud faces.png',
                
            ];

            let currentGifIndex = 0;
            const cloudGif = new Image();
            cloudGif.src = gifUrls[currentGifIndex];

            function shuffleGif() {
                currentGifIndex = (currentGifIndex + 1) % gifUrls.length;
                cloudGif.src = gifUrls[currentGifIndex];
            }

            function applyFriction(circle) {
                let speed = Math.sqrt(circle.vx * circle.vx + circle.vy * circle.vy);
                if (speed > minSpeed) {
                    circle.vx *= frictionFactor;
                    circle.vy *= frictionFactor;
                } else {
                    let angle = Math.atan2(circle.vy, circle.vx);
                    circle.vx = minSpeed * Math.cos(angle);
                    circle.vy = minSpeed * Math.sin(angle);
                }
            }

            function distanceToCenter(circle) {
                const dx = windowCirclePos.x - circle.x;
                const dy = windowCirclePos.y - circle.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function initiateReturn() {
                isReturning = true;
                returnStartTime = Date.now();
                circles.forEach(circle => {
                    circle.startX = circle.x;
                    circle.startY = circle.y;
                    circle.distance = distanceToCenter(circle);
                });
            }

            function updateReturnMotion(circle) {
                const elapsedTime = Date.now() - returnStartTime;
                const progress = Math.min(elapsedTime / returnDuration, 1);
                
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                const dx = windowCirclePos.x - circle.startX;
                const dy = windowCirclePos.y - circle.startY;
                
                circle.x = circle.startX + dx * easeProgress;
                circle.y = circle.startY + dy * easeProgress;

                if (progress === 1 && circle === circles[0]) {
                    isReturning = false;
                    initiateExplosiveRelease();
                    shuffleGif();
                }
            }

            function initiateExplosiveRelease() {
                circles.forEach(circle => {
                    const angle = Math.random() * Math.PI * 2;
                    circle.vx = Math.cos(angle) * explosiveSpeed;
                    circle.vy = Math.sin(angle) * explosiveSpeed;
                });
            }

            function drawWindowCircle() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(windowCirclePos.x, windowCirclePos.y, windowCirclePos.radius - remToPx(0.5), 0, Math.PI * 2);
                ctx.clip();
                ctx.fillStyle = `rgb(135, 206, 235)`;
                ctx.fillRect(windowCirclePos.x - windowCirclePos.radius, windowCirclePos.y - windowCirclePos.radius, windowCirclePos.radius * 2, windowCirclePos.radius * 2);
                ctx.drawImage(cloudGif, windowCirclePos.x - windowCirclePos.radius, windowCirclePos.y - windowCirclePos.radius, windowCirclePos.radius * 2, windowCirclePos.radius * 2);
                ctx.restore();
                ctx.beginPath();
                ctx.arc(windowCirclePos.x, windowCirclePos.y, windowCirclePos.radius - remToPx(0.5), 0, Math.PI * 2);
                ctx.strokeStyle = `rgb(135, 206, 235)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawWindowCircle();

                ctx.globalCompositeOperation = blendModeSelect.value;
                const opacity = opacityInput.value;

                circles.forEach(circle => {
                    if (isReturning) {
                        updateReturnMotion(circle);
                    } else {
                        applyFriction(circle);
                        circle.x += circle.vx;
                        circle.y += circle.vy;

                        if (circle.x + circle.radius > canvas.width || circle.x - circle.radius < 0) {
                            circle.vx *= -1;
                        }
                        if (circle.y + circle.radius > canvas.height || circle.y - circle.radius < 0) {
                            circle.vy *= -1;
                        }
                    }

                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${circle.color[0]}, ${circle.color[1]}, ${circle.color[2]}, ${opacity})`;
                    ctx.fill();
                });

                requestAnimationFrame(animate);
            }

            cloudGif.onload = animate;

            canvas.addEventListener('click', (event) => {
                if (!isReturning) {
                    initiateReturn();
                }
            });

            window.addEventListener('resize', () => {
                resizeCanvas();
                windowCirclePos = updateWindowCirclePosition();
                const newRadius = remToPx(circleDiameter) / 2;
                circles.forEach(circle => {
                    circle.radius = newRadius;
                });
            });

            console.log('Animation script loaded and running');
        })();
    </script>
</body>
</html>
